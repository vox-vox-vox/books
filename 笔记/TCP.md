1. 流量控制
2. 2MSL 


# TCP基本认知
- socket=端口号+IP地址，表征了TCP的连接双端
- 面向连接，提供可靠服务，支持点对点单播
- ![image.png](http://47.100.67.5:8090/upload/2021/05/image-02abcf27a1d0476c9220215d9b265925.png)
  ![image.png](http://47.100.67.5:8090/upload/2021/05/image-cef5475e8c534c499ce5172c27000eb4.png)
- 
# TCP报文结构
![image.png](http://47.100.67.5:8090/upload/2021/05/image-849f2b0300f04e2b97d09de2cadaf9fd.png)
- 端口号：TCP连接的单位是进程，进程的单位就是端口号
- 序号seq：本报文段所发送数据的第一个字节的序号【假设报文段长度1000字节，现有5000字节的数据，报文段1的seq=1，报文段2的seq=1001，报文段3的seq=2001...】
- 确认号ack：期望收到对方的下一个报文段的数据的第一个字节的序号。
- ACK：ACK=1时ack字段才有效
- SYN：SYN=1表示是一个连接请求或连接接受报文
- FIN：FIN=1表示是一个发起连接释放的报文
- PSH：理解为携带数据段
- RST：TCP处理程序会在自己认为的异常时刻发送RST包。例如，A向B发起连接，但B之上并未监听相应的端口，这时B操作系统上的TCP处理程序会发RST包。
- 窗口(rwnd)：让对方设置窗口大小的依据，单位为字节

# TCP可靠传输的原理：自动重传（Automatic Repeat reQuest）
## 1. 停止等待ARQ
> **停止等待，就是每发送完一个分组就停止发送，等待对方确认，对方确认之后再发送下一个分组**

### 1.1 具体过程与意外CASE
```C
A==========TCP==========B

A从发完报文段后就等待重传，过了时间还没收到ACK就视为有错误，重传。
B发现有错误（校验后）或没收到都不传，只有成功才传ACK

CASE1：B发的ACK超时了，造成A重新发了报文
利用编号解决，报文和对应ACK都要编号，而且要一致！

具体超时原因，还分两种情况：
CASE1.1：确认丢失了
CASE1.2：确认迟到了(这时就看出对ACK编号的必要性)(见下图)【如果不对ACK标号，A会误以为迟到的ACK1是对M2的确认】
```
![image.png](http://47.100.67.5:8090/upload/2021/05/image-c748e675e3bc48499997ced9ff82d961.png)

### 1.2 性能
简单，信道利用率低，加流水好一些
![image.png](http://47.100.67.5:8090/upload/2021/05/image-d83d8791eadb4103a68abf158c884bb8.png)

## 2. 连续ARQ
> 连续ARQ = 滑动窗口 + 超时重传
### 2.1 具体过程和CASE
通过和停等ARQ的对比，引入连续ARQ的概念
![image.png](http://47.100.67.5:8090/upload/2021/05/image-f3532ca182c34d72a3f5038e0a3ba88f.png)
1. 一次按序发送多个分组
2. 采用滑动窗口【见下一节】发送，而不是像 停等ARQ一样 一个一个的发。
3. **累计确认** 是指，接收端在依次确认发来的消息正确后，**只传回最后一个**【如发来2，3，4，5都正确，只传回ACK5】，表示**到这个分组为止的所有分组都已经成功收到**
4. GO-BY-N是指不得不回退发送N（多于1个）个消息包。【如果发送方发送了前5个分组，而中间的第3个分组丢失了。这时接收方只能对前2个分组发出确认。发送方无法知道后面3个分组的下落，而只好把后面的3个分组都再重传一次。】

连续ARQ虽然基于滑动窗口，但是接收端在遇到错误后，仍然是不给发送端发，所以本质上它的错误处理机制还是超时重传。


### 2.2 滑动窗口的具体细节
1. 维护两个滑动窗口，一个发送窗口，一个接收窗口。
窗口单位：**字节**
发送窗口：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。
接收窗口：只允许接收落入窗口内的数据。 
![image.png](http://47.100.67.5:8090/upload/2021/05/image-5577cc28d1c9424185166b24a912a6a8.png)

2. 窗口扩张收缩策略如下：
发送窗口：收到接受窗口发回的确认消息（ACK）后，将窗口向后平移。
接受窗口：收到发送窗口发来的消息并确认无误后，自主向后平移。

### 2.3 TCP发送信息抓包验证

验证环境：简单echo回射server，client发送给server`aaaaa`，server回复给cli`AAAAA`

![image-20211129202349189](https://tva1.sinaimg.cn/large/008i3skNgy1gwwah6viuuj313b023wf9.jpg)

- 5 ：cli发送给ser的request，PSH表示携带信息，Seq=1表示cli端-->ser端的连接从1开始计数，Len=6表示长度为6个字节，可以看出是实际是：`61 61 61 61 61 0a`，`0a`是回车
- 6 ：ser回复cli的报文，Ack=7可以看出在Seq的基础上加了6，说明这是一个累计确认，Len=0说明不携带数据
- 7 ：ser回复给cli的response，Seq=1表示ser端-->cli端的连接也从1开始计数，Ack=7还是说明ser希望cli下一个数据包从seq=7开始发，Len=6实际上是`41 41 41 41 41 0a`，`0a`是回车
- 8 ：cli回复给ser的报文，Seq=7表明此数据包从7开始，Ack=7也表示这是一个累计确认。

# TCP 拥塞控制

> 拥塞：网络中某资源的需求超过了该资源的能力范围，网络整体性能变差。类似于某一个地方堵了。

**TCP的拥塞控制方法**：基于拥塞窗口（cwnd）的控制法。**发送方**维护一个拥塞窗口(cwnd)，发送窗口的真正大小不仅取决于接收方窗口(rwnd)，还取决于网络拥塞状况(cwnd会根据网络拥塞状况动态调整)。
**真正的发送窗口值=Min(rwnd，cwnd)**

## 拥塞检测
- 定时器超时：网络已经发生了拥塞
- 收到三个重复的ACK：网络可能会发生拥塞
**这里和之前有点不一样：**根据前面的知识我们知道，TCP之前是按照累计确认机制发送ACK报文的，但是这种累计确认机制效率比较低，现在的TCP通常采用一种叫**选择确认**的机制。
选择确认机制就是有选择性地告诉发送端失序的数据块是哪个，以便其使用快重传【这个是tcp的一种增强特性，叫做Fast Retransmit & Recovery （FRR），机制是当接收方发现丢包/乱序时，马上发送重复的ACK给发送方，当发送方收到三个重复的ACK时，就确认丢包了，马上进行重传，这样就不需要等待计时器超时了。】机制。
一个例子：
![image.png](http://47.100.67.5:8090/upload/2021/05/image-d5cb581598734334afa4f4e33148f39b.png)


## 拥塞控制算法
> 【慢开始，拥塞避免】；【快重传；快恢复】

**慢开始**：按照传输轮次，指数增长cwnd的大小，直至阈值(ssthresh)。
**拥塞避免**：到达阈值(ssthresh)后，按照传输轮次，线性增长cwnd的大小，直至检测到拥塞。

**快重传**：3-ACK时进行。目的是为了告诉发送方**不要等待超时重传了！而是立即重传3-ACK所要求的那部分报文！**
**快恢复**：3-ACK时进行。将阈值(ssthresh)减半，并将cwnd设为阈值(ssthresh)，继续进行拥塞避免。由于没有变为“慢开始”，因此叫“快恢复”
流程如下图：
![image.png](http://47.100.67.5:8090/upload/2021/05/image-797b4b8fea1647d6bcf676364bf9538b.png)

某一次运行示例：
![image.png](http://47.100.67.5:8090/upload/2021/05/image-486fb3ca61fb4bf781f6389a500550bb.png)

下面对图进行解释：
- 横坐标是**传输轮次**。传输轮次的一轮表示 **把窗口cwnd所允许的报文都发出去，再收到对最后一个字节的ACK**
- 纵坐标是cwnd
- 1. 到达阈值(ssthresh)，由慢开始到拥塞避免
- 2. 发生超时！阈值减少(ssthresh=cwnd/2)，重新慢开始
- 3. 又到达阈值(ssthresh)，由慢开始到拥塞避免
- 4. 出现3-ACK，执行快重传，快恢复，阈值减少(ssthresh=ssthresh/2)
- 5. 由于快恢复，继续进入拥塞避免阶段


# TCP的三次握手和四次挥手
## 0. 报文与符号约定
- **seq**：报文段发送的数据的第一个字节的序号（index），由于TCP是流传输，接收端需要知道报文段中的第一个字节是这个流中的哪一个字节。
- **ACK**：为1说明这个报文是一个连接确认报文。
- **ack**：确认编号(Acknowledgement Number)，即接收到的上一次远端主机传来的seq然后+1，再发送给远端主机。提示远端主机已经成功接收上一次所有数据。
- **SYN**：为1说明这个报文是一个连接请求报文。
- **FIN**：为1说明这个报文是一个终止连接报文。
## 1. 三次握手过程
刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。 进行三次握手：
![](https://user-gold-cdn.xitu.io/2019/10/8/16da9fd28a45bd19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

- 第一次握手：客户端给服务端发一个 SYN 报文。此时客户端处于 SYN_SEND 状态。
>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。
> 确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。
> 确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。

在socket编程中，客户端执行connect()时，将触发三次握手。

## 2. 两次握手不行吗
**不行**

TCP连接是双工的，两次握手只能代表client到server这一条tcp连接是可靠的

如果想验证server到client这一条连接是否可靠，则需要client再次发给server一个ACK，也就是第3次握手

## 3. 四次挥手过程
刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：
![image.png](http://47.100.67.5:8090/upload/2021/05/image-b0f9a67c02184306bc4987cb655ca07c.png)
- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。
即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。

- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于**半关闭**状态，**客户端到服务端的连接释放**。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。

- 中间状态：挥手是客户端自己发起的，有可能服务端还有数据没有给客户端传完，这时候继续传数据。


- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。

- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。
即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。


## 4. 为什么要等待2MSL(Maximum Segment Lifetime)
1. **为了保证A发送的最后一个ACK报文能够到达B。** 这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认。B会超时重传这个FIN+ACK报文段，而A就能在2MSL时间内收到这个重传的FIN+ACK报文段。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后就立即释放连接，就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常的步骤进入CLOSED状态。

![A关了，就全完了](http://47.100.67.5:8090/upload/2021/05/image-d8fe5363257044558313208d8848a884.png)

2. A在发送完ACK报文段后，再经过2MSL时间，就可以**使本连接持续的时间所产生的所有报文段都从网络中消失。** 这样就可以使下一个新的连接中不会出现这种旧的连接请求的报文段。





## 10.28 补
![IMG_102420211028142431.PNG](http://47.100.67.5:8090/upload/2021/10/IMG_1024(20211028-142431)-e6fe35d946de4b018c7e12eaca0c2386.PNG)

tcp是双向连接，client会给server发信息，server也会给client发信息
tcp两次握手能保证client给服务端发信息成功了
但是无法保证server给client发信息成功了
所以client必须再发一个ack，这样server就它发给client的信息也能成功
总的来说，全双工通信，保证可靠性，需要两方都ack
seq也要初始化两个，分别针对一个方向的连接开始自增。上图中一个方向是10000，一个方向是20000
ack都是在seq的基础上+1

![IMG_102520211028142444.PNG](http://47.100.67.5:8090/upload/2021/10/IMG_1025(20211028-142444)-f770da3a8b6c4bcd8b2ef110a5d28616.PNG)

最少三次握手才能保证两个SYN,两个ACK
为什么不是三次挥手，而是4次挥手
因为中间server还有东西要发，所以ack和fin要分开了，但是握手的时候ack和SYN是在一次发送的
所以就从3次变成了4次




# UDP
## UDP基础知识
1. UDP 是无连接的，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
2. UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
3. UDP 是面向报文的。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 一次交付一个完整的报文。 
4. UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的。很适合多媒体通信的要求。 
5. UDP 支持一对一、一对多、多对一和多对多的交互通信。
6. UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。

